#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const fs_1 = require("fs");
const path_1 = require("path");
const commander_1 = require("commander");
const gradient_string_1 = __importDefault(require("gradient-string"));
const d_fi_core_1 = require("d-fi-core");
const prompts_1 = __importDefault(require("prompts"));
const log_update_1 = __importDefault(require("log-update"));
const p_queue_1 = __importDefault(require("p-queue"));
const chalk_1 = __importDefault(require("chalk"));
const true_case_path_1 = require("true-case-path");
const signale_1 = __importDefault(require("./lib/signale"));
const download_track_1 = __importDefault(require("./lib/download-track"));
const config_1 = __importDefault(require("./lib/config"));
const update_check_1 = __importDefault(require("./lib/update-check"));
const auto_updater_1 = __importDefault(require("./lib/auto-updater"));
const util_1 = require("./lib/util");
const package_json_1 = __importDefault(require("../package.json"));



const CHelp = {    
    getPropsOf(obj, props = []){
        return obj == null ? props :
        CHelp.getPropsOf(Object.getPrototypeOf(obj),
        props.concat(Object.getOwnPropertyNames(obj)+": "+obj[Object.getOwnPropertyNames(obj)]));
    },
};
// App info
console.log((0, gradient_string_1.default)('red', 'yellow', 'orange')(`             ♥ d-fi - ${package_json_1.default.version} ♥         `) +
    '\n' +
    (0, gradient_string_1.default)('orange', 'yellow', 'red')(' ──────────────────────────────────────────────') +
    '\n' +
    (0, gradient_string_1.default)('red', 'yellow', 'orange')(' │ repo   https://notabug.org/sayem314/d-fi  │ ') +
    '\n' +
    (0, gradient_string_1.default)('red', 'yellow', 'orange')(' │ github https://github.com/sayem314        │ ') +
    '\n' +
    (0, gradient_string_1.default)('red', 'yellow', 'orange')(' │ coffee https://ko-fi.com/sayemchowdhury   │ ') +
    '\n' +
    (0, gradient_string_1.default)('red', 'yellow', 'orange')(' ──────────────────────────────────────────────'));
const cmd = new commander_1.Command()
    .option('-q, --quality <quality>', 'The quality of the files to download: 128/320/flac ')
    .option('-o, --output <template>', 'Output filename template')
    .option('-u, --url <url>', 'Deezer album/artist/playlist/track url')
    .option('-i, --input-file <file>', 'Downloads all urls listed in text file')
    .option('-c, --concurrency <number>', 'Download concurrency for album, artists and playlist')
    .option('-a, --set-arl <string>', 'Set arl cookie')
    .option('-d, --headless', 'Run in headless mode for scripting automation', false)
    .option('-conf, --config-file <file>', 'Custom location to your config file', 'd-fi.config.json')
    .option('-rfp, --resolve-full-path', 'Use absolute path for playlists')
    .option('-cp, --create-playlist', 'Force create a playlist file for non playlists');
if (process.pkg) {
    cmd.option('-U, --update', 'Update this program to latest version');
}
const options = cmd.parse(process.argv).opts();
if (!options.url && cmd.args[0]) {
    options.url = cmd.args[0];
}
if (options.headless && !options.quality) {
    console.error(signale_1.default.error('Missing parameters --quality'));
    console.error(signale_1.default.note('Quality must be provided with headless mode'));
    process.exit(1);
}
if (options.headless && !options.url && !options.inputFile) {
    console.error(signale_1.default.error('Missing parameters --url'));
    console.error(signale_1.default.note('URL must be provided with headless mode'));
    process.exit(1);
}
const conf = new config_1.default(options.configFile);
if (conf.userConfigLocation) {
    console.log(signale_1.default.info('Config loaded --> ' + conf.userConfigLocation));
}
const queue = new p_queue_1.default({ concurrency: Number(options.concurrency || conf.get('concurrency')) });
const urlRegex = /https?:\/\/.*\w+\.\w+\/\w+/;
const onCancel = () => {
    console.info(signale_1.default.note('Aborted!'));
    process.exit();
};
const startDownload = async (saveLayout, url, skipPrompt) => {
    try {
        if (!options.quality) {
            const { musicQuality } = await (0, prompts_1.default)([
                {
                    type: 'select',
                    name: 'musicQuality',
                    message: 'Pick music quality:',
                    choices: [
                        { title: 'MP3  - 128 kbps', value: '128' },
                        { title: 'MP3  - 320 kbps', value: '320' },
                        { title: 'FLAC - 1411 kbps', value: 'flac' },
                    ],
                    initial: 1,
                },
            ], { onCancel });
            options.quality = musicQuality;
        }
        if (!url) {
            const { query } = await (0, prompts_1.default)([
                {
                    type: 'text',
                    name: 'query',
                    message: 'Enter URL or search:',
                    validate: (value) => (value ? true : false),
                },
            ], { onCancel });
            url = query;
        }
        let searchData = null;
        if (!url.match(urlRegex)) {
            if (options.headless) {
                throw new Error('Please provide a valid URL. Unknown URL: ' + url);
            }
            const { TRACK } = await (0, d_fi_core_1.searchMusic)(url, ['TRACK']);
            searchData = {
                info: { type: 'track', id: url },
                linktype: 'track',
                linkinfo: {},
                tracks: TRACK.data.map((t) => {
                    if (t.VERSION && !t.SNG_TITLE.includes(t.VERSION)) {
                        t.SNG_TITLE += ' ' + t.VERSION;
                    }
                    return t;
                }),
            };
        }
        else if (url.match(/playlist|artist/)) {
            console.log(signale_1.default.info('Fetching data. Please hold on.'));
        }
        const data = searchData ? searchData : await (0, d_fi_core_1.parseInfo)(url);
        if (!options.headless && data.tracks.length > 1) {
            const choices = await (0, prompts_1.default)([
                {
                    type: 'multiselect',
                    name: 'items',
                    message: `Select songs to download. Total of ${data.tracks.length} tracks.`,
                    choices: data.tracks.map((t) => ({
                        title: t.SNG_TITLE,
                        value: t,
                        description: `Artist: ${t.ART_NAME}\nAlbum: ${t.ALB_TITLE}\nDuration: ${(0, util_1.formatSecondsReadable)(Number(t.DURATION))}`,
                    })),
                },
            ], { onCancel });
            data.tracks = choices.items;
        }
        if (data && data.tracks.length > 0) {
            console.log(signale_1.default.info(`Proceeding download of ${data.tracks.length} tracks. Be patient.`));
            if (data.linktype === 'playlist') {
                const filteredTracks = data.tracks.filter((item, index, self) => index === self.findIndex((t) => t.SNG_ID === item.SNG_ID));
                const duplicateTracks = data.tracks.length - filteredTracks.length;
                if (duplicateTracks > 0) {
                    data.tracks = filteredTracks
                        .sort((a, b) => a.TRACK_POSITION - b.TRACK_POSITION)
                        .map((t, i) => {
                        t.TRACK_POSITION = i + 1;
                        return t;
                    });
                    console.log(signale_1.default.warn(`Removed ${duplicateTracks} duplicate ${duplicateTracks > 1 ? 'tracks' : 'track'}.`));
                }
            }
            
            const coverSizes = conf.get('coverSize');
            const trackNumber = conf.get('trackNumber', true);
            const fallbackTrack = conf.get('fallbackTrack', true);
            const fallbackQuality = conf.get('fallbackQuality', true);
            let resolveFullPath = options.resolveFullPath;
            if(resolveFullPath == undefined )resolveFullPath = conf.get('playlist.resolveFullPath');
            const savedFiles = [];
            let m3u8 = [];
            
            await queue.addAll(data.tracks.map((track, index) => {
                return async () => {
                    const savedPath = await (0, download_track_1.default)({
                        track,
                        quality: options.quality,
                        info: data.linkinfo,
                        coverSizes,
                        path: options.output ? options.output : saveLayout[data.linktype],
                        totalTracks: data ? data.tracks.length : 10,
                        trackNumber,
                        fallbackTrack,
                        fallbackQuality,
                        message: `(${index}/${data.tracks.length})`,
                    });
                    // Add to saved list
                    if (savedPath) {
                        m3u8.push((0, path_1.resolve)(process.env.SIMULATE ? savedPath : (0, true_case_path_1.trueCasePathSync)(savedPath)));
                        savedFiles.push(savedPath);
                    }
                };
            }));
            
            // Display downloaded location
            if (savedFiles.length > 0) {
                const savedIn = new Set(savedFiles.map((l) => (0, path_1.dirname)(l)));
                console.log(signale_1.default.info('Saved in ' + [...savedIn].map((d) => chalk_1.default.bgGreen(d)).join(', ')));
            }
            if ((options.createPlaylist || data.linktype === 'playlist') && !process.env.SIMULATE && m3u8.length > 1) {
                const playlistDir = (0, util_1.commonPath)([...new Set(savedFiles.map(path_1.dirname))]);
                const playlistFile = (0, path_1.join)(playlistDir, (0, util_1.sanitizeFilename)(data.linkinfo.TITLE || data.linkinfo.ALB_TITLE));
                if (!resolveFullPath) {
                    const resolvedPlaylistDir = (0, path_1.resolve)(playlistDir) + path_1.sep;
                    m3u8 = m3u8.map((file) => file.replace(resolvedPlaylistDir, ''));
                }
                const m3u8Content = '#EXTM3U' + os_1.EOL + m3u8.sort().join(os_1.EOL);
                (0, fs_1.writeFileSync)(playlistFile + '.m3u8', m3u8Content, { encoding: 'utf-8' });
            }
        }
        else {
            console.log(signale_1.default.info('No items to download!'));
        }
    }
    catch (err) {
        console.error(signale_1.default.error(err.message));
        //console.log(CHelp.getPropsOf(err));
    }
    // Ask for new download
    if (!options.headless && !skipPrompt) {
        startDownload(saveLayout, '', skipPrompt);
    }
};
/**
 * Application init.
 */
const initApp = async () => {
    if (options.setArl) {
        const configPath = conf.set('cookies.arl', options.setArl);
        console.log(signale_1.default.info('cookies.arl set to --> ' + options.setArl));
        console.log(signale_1.default.note(configPath));
        process.exit();
    }
    (0, log_update_1.default)(signale_1.default.pending('Initializing session...'));
    const arl = conf.get('cookies.arl');
    (0, log_update_1.default)(signale_1.default.pending('Verifying session...'));
    await (0, d_fi_core_1.initDeezerApi)(arl);
    const { BLOG_NAME } = await (0, d_fi_core_1.getUser)();
    (0, log_update_1.default)(signale_1.default.success('App is Logged in as ' + BLOG_NAME));
    log_update_1.default.done();
    const saveLayout = conf.get('saveLayout');
    if (options.inputFile) {
        const lines = (0, fs_1.readFileSync)(options.inputFile, 'utf-8').split(/\r?\n/);
        for await (const line of lines) {
            if (line && line.match(urlRegex)) {
                console.log(signale_1.default.info('Starting download: ' + line));
                await startDownload(saveLayout, line.trim(), true);
            }
        }
    }
    else {
        startDownload(saveLayout, options.url, false);
    }
};
if (options.update) {
    (0, auto_updater_1.default)(package_json_1.default).catch((err) => {
        console.error(signale_1.default.error(err.message));
        //console.log(CHelp.getPropsOf(err));
        process.exit(1);
    });
}
else {
    // Check for update
    (0, update_check_1.default)(package_json_1.default);
    // Init interface
    initApp().catch((err) => {
        console.error(signale_1.default.error(err.message));
        //console.log(CHelp.getPropsOf(err));
        process.exit(1);
    });
}


// /data/data/com.termux/files/home/.npm-packages/lib/node_modules/d-fi