"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addTrackTags = void 0;
const abumCover_1 = require("./abumCover");
const getTrackLyrics_1 = require("./getTrackLyrics");
const id3_1 = require("./id3");
const flacmetata_1 = require("./flacmetata");
const api_1 = require("../api");
const albumInfo = async (track) => {
    try {
        return await (0, api_1.getAlbumInfoPublicApi)(track.ALB_ID);
    }
    catch (err) {
        return null;
    }
};
/**
 * Add metdata to the mp3
 * @param {Buffer} trackBuffer decrypted track buffer
 * @param {Object} track json containing track infos
 * @param {Number} albumCoverSize album cover size in pixel
 */
const addTrackTags = async (trackBuffer, track, albumCoverSize = 1000) => {
    const [cover, lyrics, album] = await Promise.all([
        (0, abumCover_1.downloadAlbumCover)(track, albumCoverSize),
        (0, getTrackLyrics_1.getTrackLyrics)(track),
        albumInfo(track),
    ]);
    if (lyrics) {
        track.LYRICS = lyrics;
    }
    if (track.ART_NAME.toLowerCase() === 'various') {
        track.ART_NAME = 'Various Artists';
    }
    if (album && album.record_type) {
        album.record_type =
            album.record_type === 'ep' ? 'EP' : album.record_type.charAt(0).toUpperCase() + album.record_type.slice(1);
    }
    const isFlac = trackBuffer.slice(0, 4).toString('ascii') === 'fLaC';
    return isFlac
        ? (0, flacmetata_1.writeMetadataFlac)(trackBuffer, track, album, albumCoverSize, cover)
        : (0, id3_1.writeMetadataMp3)(trackBuffer, track, album, cover);
};
exports.addTrackTags = addTrackTags;
